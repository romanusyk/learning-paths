---
title: "The Method Trap: Why One Size Doesn't Fit All"
format:
  html:
    toc: false
    number-sections: false
    code-fold: true
    page-layout: full
---

> "I wish I had never chosen this method." — *Survey Respondent*

Finding an effective learning strategy is often a process of trial and error. Our survey reveals that **one in three respondents** found at least one popular method to be "completely useless."

This page analyses the effectiveness and engagement of various learning methods, from private lessons to speaking clubs, to help you find what might work for you.

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from collections import Counter

df = pd.read_csv('../data/form_data.csv')

# Method effectiveness columns
effectiveness_cols = [
    'method_effectiveness:online_courses',
    'method_effectiveness:private_lessons', 
    'method_effectiveness:textbooks',
    'method_effectiveness:watching_movies',
    'method_effectiveness:audio',
    'method_effectiveness:speaking_club',
    'method_effectiveness:reading_books',
    'method_effectiveness:work_tasks'
]

# Engagement/motivation columns
engagement_cols = [
    'motives:online_exercises',
    'motives:speaking_club',
    'motives:watching_movies', 
    'motives:reading_books',
    'motives:work_tasks',
    'motives:gamified_learning',
    'motives:personalised_feedback'
]

# Clean method names for display
def clean_method_name(col_name):
    if col_name.startswith('method_effectiveness:'):
        return col_name.replace('method_effectiveness:', '').replace('_', ' ').title()
    elif col_name.startswith('motives:'):
        return col_name.replace('motives:', '').replace('_', ' ').title()
    return col_name

print(f"Total respondents: {len(df)}")
```

## Method Effectiveness

This chart shows how respondents rated the effectiveness of each learning method. For each method, you can see how many people gave each rating (on a 1-5 scale). The methods are:

- **Online Courses**: Structured online learning programs and platforms
- **Private Lessons**: One-on-one tutoring with individual instructors  
- **Textbooks**: Traditional printed or digital learning materials
- **Watching Movies**: Learning through English-language films and TV shows
- **Audio**: Podcasts, music, and other audio content in English
- **Speaking Club**: Group conversation practice sessions
- **Reading Books**: Literature, articles, and other written content in English
- **Work Tasks**: Learning English through professional activities and job requirements

```{python}
# Create effectiveness distribution chart
# Define colours for each rating (1-5)
rating_colors = {1: '#FF4B4B', 2: '#FF8C42', 3: '#FFD23F', 4: '#8FBC8F', 5: '#32CD32'}

# Prepare data and calculate average for sorting
method_data_eff = []

for col in effectiveness_cols:
    method_name = clean_method_name(col)
    
    # Get non-null values and convert to numeric
    values = pd.to_numeric(df[col], errors='coerce').dropna()
    
    if len(values) == 0:
        # Fill with zeros if no data
        percentages = {rating: 0 for rating in range(1, 6)}
        avg_effectiveness = 0
    else:
        # Calculate percentage distribution
        value_counts = values.value_counts().sort_index()
        total = len(values)
        
        # Fill percentages for each rating (1-5)
        percentages = {}
        for rating in range(1, 6):
            pct = round(value_counts.get(rating, 0) / total * 100, 1) if total > 0 else 0
            percentages[rating] = pct
        
        # Calculate average effectiveness for sorting
        avg_effectiveness = values.mean()
    
    method_data_eff.append({
        'name': method_name,
        'percentages': percentages,
        'avg_effectiveness': avg_effectiveness
    })

# Sort by average effectiveness (descending)
method_data_eff.sort(key=lambda x: x['avg_effectiveness'], reverse=True)

# Extract sorted data
method_names_eff = [item['name'] for item in method_data_eff]
all_percentages = {rating: [item['percentages'][rating] for item in method_data_eff] for rating in range(1, 6)}

# Create the combined horizontal bar chart
fig, ax = plt.subplots(figsize=(12, 10))

y_pos = np.arange(len(method_names_eff))
bar_height = 0.15
spacing = 0.02

# Create bars for each rating
for i, rating in enumerate(range(1, 6)):
    y_positions = y_pos + (i - 2) * (bar_height + spacing)
    bars = ax.barh(y_positions, all_percentages[rating], bar_height, 
                   label=f'Rating {rating}', color=rating_colors[rating], alpha=0.8)
    
    # Add percentage labels on bars (only if percentage > 2% to avoid clutter)
    for bar, pct in zip(bars, all_percentages[rating]):
        if pct > 2:
            width = bar.get_width()
            ax.text(width + 0.5, bar.get_y() + bar.get_height()/2.,
                    f'{pct}%', ha='left', va='center', fontsize=9)

ax.set_yticks(y_pos)
ax.set_yticklabels(method_names_eff, fontsize=12)
ax.set_xlabel('Percentage', fontsize=13)
ax.set_title('Method Effectiveness Rating Distribution', fontsize=16, fontweight='bold', pad=20)
ax.legend(loc='upper right', fontsize=11)
ax.grid(axis='x', alpha=0.3)
ax.tick_params(axis='x', labelsize=11)
ax.set_xlim(0, max([max(all_percentages[r]) for r in range(1, 6)]) * 1.1)

plt.tight_layout()
plt.show()
```

## Method Engagement

This chart shows how engaging respondents found each learning method. For each method, you can see how many people gave each rating (on a 1-5 scale). The methods are:

- **Online Exercises**: Interactive digital activities and practice tasks
- **Speaking Club**: Group conversation and discussion sessions  
- **Watching Movies**: Engaging with English-language films and TV content
- **Reading Books**: Enjoying literature and written materials in English
- **Work Tasks**: Professional activities that require English skills
- **Gamified Learning**: Game-like learning experiences with rewards and progression
- **Personalised Feedback**: Individual assessment and customized guidance

```{python}
# Create engagement distribution chart
# Prepare data and calculate average for sorting
method_data_eng = []

for col in engagement_cols:
    method_name = clean_method_name(col)
    
    # Get non-null values and convert to numeric
    values = pd.to_numeric(df[col], errors='coerce').dropna()
    
    if len(values) == 0:
        # Fill with zeros if no data
        percentages = {rating: 0 for rating in range(1, 6)}
        avg_engagement = 0
    else:
        # Calculate percentage distribution
        value_counts = values.value_counts().sort_index()
        total = len(values)
        
        # Fill percentages for each rating (1-5)
        percentages = {}
        for rating in range(1, 6):
            pct = round(value_counts.get(rating, 0) / total * 100, 1) if total > 0 else 0
            percentages[rating] = pct
        
        # Calculate average engagement for sorting
        avg_engagement = values.mean()
    
    method_data_eng.append({
        'name': method_name,
        'percentages': percentages,
        'avg_engagement': avg_engagement
    })

# Sort by average engagement (descending)
method_data_eng.sort(key=lambda x: x['avg_engagement'], reverse=True)

# Extract sorted data
method_names_eng = [item['name'] for item in method_data_eng]
all_percentages_eng = {rating: [item['percentages'][rating] for item in method_data_eng] for rating in range(1, 6)}

# Create the combined horizontal bar chart
fig, ax = plt.subplots(figsize=(12, 9))

y_pos = np.arange(len(method_names_eng))
bar_height = 0.15
spacing = 0.02

# Create bars for each rating
for i, rating in enumerate(range(1, 6)):
    y_positions = y_pos + (i - 2) * (bar_height + spacing)
    bars = ax.barh(y_positions, all_percentages_eng[rating], bar_height, 
                   label=f'Rating {rating}', color=rating_colors[rating], alpha=0.8)
    
    # Add percentage labels on bars (only if percentage > 2% to avoid clutter)
    for bar, pct in zip(bars, all_percentages_eng[rating]):
        if pct > 2:
            width = bar.get_width()
            ax.text(width + 0.5, bar.get_y() + bar.get_height()/2.,
                    f'{pct}%', ha='left', va='center', fontsize=9)

ax.set_yticks(y_pos)
ax.set_yticklabels(method_names_eng, fontsize=12)
ax.set_xlabel('Percentage', fontsize=13)
ax.set_title('Method Engagement Rating Distribution', fontsize=16, fontweight='bold', pad=20)
ax.legend(loc='upper right', fontsize=11)
ax.grid(axis='x', alpha=0.3)
ax.tick_params(axis='x', labelsize=11)
ax.set_xlim(0, max([max(all_percentages_eng[r]) for r in range(1, 6)]) * 1.1)

plt.tight_layout()
plt.show()
```

## Effectiveness vs Engagement

This chart compares the average effectiveness and engagement ratings for each method, shown side by side:

```{python}
# Calculate averages for methods
# Group similar methods together
all_methods = {
    'Speaking clubs': (['method_effectiveness:speaking_club'], ['motives:speaking_club']),
    'Movies & Music': (['method_effectiveness:watching_movies', 'method_effectiveness:audio'], ['motives:watching_movies']),
    'Books': (['method_effectiveness:reading_books', 'method_effectiveness:textbooks'], ['motives:reading_books']),
    'Practice at work': (['method_effectiveness:work_tasks'], ['motives:work_tasks']),
    'Online drills': (['method_effectiveness:online_courses'], ['motives:online_exercises', 'motives:gamified_learning']),
    'Private lessons': (['method_effectiveness:private_lessons'], ['motives:personalised_feedback']),
}

# Prepare data for combined chart and calculate averages for sorting
combined_method_data = []

for method_name, (eff_cols, eng_cols) in all_methods.items():
    # Calculate effectiveness average - stack all values from all effectiveness columns
    all_eff_values = []
    for eff_col in eff_cols:
        eff_values = pd.to_numeric(df[eff_col], errors='coerce').dropna()
        all_eff_values.extend(eff_values.tolist())
    eff_avg = np.mean(all_eff_values) if all_eff_values else np.nan
    
    # Calculate engagement average - stack all values from all engagement columns
    all_eng_values = []
    for eng_col in eng_cols:
        eng_values = pd.to_numeric(df[eng_col], errors='coerce').dropna()
        all_eng_values.extend(eng_values.tolist())
    eng_avg = np.mean(all_eng_values) if all_eng_values else np.nan
    
    # Use effectiveness for sorting, fall back to engagement if effectiveness is missing
    sort_score = eff_avg if not np.isnan(eff_avg) else (eng_avg if not np.isnan(eng_avg) else 0)
    
    combined_method_data.append({
        'name': method_name,
        'effectiveness': eff_avg,
        'engagement': eng_avg,
        'sort_score': sort_score
    })

# Sort by effectiveness (or engagement where effectiveness is missing), descending
combined_method_data.sort(key=lambda x: x['sort_score'], reverse=True)

# Extract sorted data
method_names = [item['name'] for item in combined_method_data]
effectiveness_scores = [item['effectiveness'] for item in combined_method_data]
engagement_scores = [item['engagement'] for item in combined_method_data]

# Create horizontal bar chart
y = np.arange(len(method_names))
height = 0.28

# Set clean font
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.sans-serif'] = ['Arial', 'Helvetica', 'DejaVu Sans']

fig, ax = plt.subplots(figsize=(11, 6))

# Create horizontal bars with clear colours
bars1 = ax.barh(y + height/2, effectiveness_scores, height, label='Effectiveness', 
                color='#3498db', alpha=0.9, edgecolor='white', linewidth=0.5)
bars2 = ax.barh(y - height/2, engagement_scores, height, label='Engagement', 
                color='#e74c3c', alpha=0.9, edgecolor='white', linewidth=0.5)

# Add value labels on bars
for i, (bar1, bar2) in enumerate(zip(bars1, bars2)):
    if not np.isnan(effectiveness_scores[i]):
        width1 = bar1.get_width()
        ax.text(width1 + 0.1, bar1.get_y() + bar1.get_height()/2.,
                f'{effectiveness_scores[i]:.1f}', ha='left', va='center', 
                fontsize=11, fontweight='bold', color='#2c3e50')
    
    if not np.isnan(engagement_scores[i]):
        width2 = bar2.get_width()
        ax.text(width2 + 0.1, bar2.get_y() + bar2.get_height()/2.,
                f'{engagement_scores[i]:.1f}', ha='left', va='center', 
                fontsize=11, fontweight='bold', color='#2c3e50')

# Clear styling
ax.set_xlabel('Rating (1 = Poor, 5 = Excellent)', fontsize=13, fontweight='600', color='#2c3e50')
ax.set_title('Which Learning Methods Work Best?', 
             fontweight='bold', fontsize=16, color='#2c3e50', pad=20)
ax.set_yticks(y)
ax.set_yticklabels(method_names, fontsize=12, fontweight='500', color='#34495e')

# Clean styling
ax.set_xticks([1, 2, 3, 4, 5])
ax.set_xticklabels(['1', '2', '3', '4', '5'], fontsize=11, color='#7f8c8d')
ax.legend(fontsize=12, loc='upper right', frameon=True, fancybox=True, 
          shadow=True, framealpha=0.9, facecolor='white')
ax.grid(axis='x', alpha=0.3, linestyle='--', linewidth=0.8, color='#bdc3c7')
ax.set_xlim(0.8, 5.2)

# Clean borders
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_color('#bdc3c7')
ax.spines['left'].set_color('#bdc3c7')
ax.spines['bottom'].set_linewidth(1.2)
ax.spines['left'].set_linewidth(1.2)

# Add subtle background colour
ax.set_facecolor('#f8f9fa')

plt.tight_layout()
plt.show()

# Reset font settings to default after the chart
plt.rcParams.update(plt.rcParamsDefault)
```

### Interactive: Other Learning Methods

The table below shows other learning methods that respondents mentioned in their answers. Use the language toggle to switch between original and English translations.

```{python}
#| echo: false
#| results: asis
import sys, os
from IPython.display import HTML, display
sys.path.append(os.path.abspath('..'))

# Create a simple table for extra methods (similar to obstacles table but without filters)
extra_methods_df = pd.read_csv('../data/extra_methods_eng.csv')

def render_extra_methods_table():
    # Build HTML for language toggle and table
    lang_toggle = '''
    <div style="margin-bottom: 1rem;" class="toolbar">
        <strong>Text language:</strong> 
        <button id="lang-original-methods" class="lang-toggle-btn active" data-lang="orig">Original</button> 
        <button id="lang-english-methods" class="lang-toggle-btn" data-lang="en">English</button>
    </div>
    '''
    
    # Build table rows
    table_rows = []
    for _, row in extra_methods_df.iterrows():
        orig_text = str(row.get('extra_methods', '') or '').strip()
        eng_text = str(row.get('extra_methods_eng', '') or '').strip()
        
        if not orig_text and not eng_text:
            continue
            
        # Get original text from form_data if available
        respondent_id = row.get('respondent_id')
        if pd.notna(respondent_id):
            form_row = df[df['respondent_id'] == respondent_id]
            if not form_row.empty:
                orig_from_form = str(form_row.iloc[0].get('extra_methods', '') or '').strip()
                if orig_from_form:
                    orig_text = orig_from_form
        
        cell_content = f'''
        <span class="methods-text">
            <span class="text-orig">{orig_text or '—'}</span>
            <span class="text-en" style="display:none">{eng_text or '—'}</span>
        </span>
        '''
        
        table_rows.append(f'<tr><td>{cell_content}</td></tr>')
    
    table_html = f'''
    <table id="extra-methods-table" class="methods-table">
        <thead><tr><th>Additional Learning Methods</th></tr></thead>
        <tbody>{''.join(table_rows)}</tbody>
    </table>
    '''
    
    # CSS styling
    css = '''
    <style>
        .lang-toggle-btn { 
            cursor: pointer; margin: 0 6px 6px 0; padding: 6px 10px; 
            border-radius: 6px; border: 1px solid #bbb; background: #fafafa; 
        }
        .lang-toggle-btn.active { background: #333; color: #fff; border-color: #333; }
        .methods-table { width: 100%; border-collapse: separate; border-spacing: 0; }
        .methods-table thead th { 
            text-align: left; border-bottom: 2px solid #ddd; padding: 8px; 
        }
        .methods-table td { 
            vertical-align: top; padding: 8px; border-bottom: 1px solid #eee; 
        }
    </style>
    '''
    
    # JavaScript for language toggle
    script = '''
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        function setMethodsLang(lang) {
            document.querySelectorAll('.methods-text .text-en').forEach(function(el) { 
                el.style.display = (lang==='en') ? '' : 'none'; 
            });
            document.querySelectorAll('.methods-text .text-orig').forEach(function(el) { 
                el.style.display = (lang==='en') ? 'none' : ''; 
            });
        }
        
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'lang-original-methods') {
                document.querySelectorAll('.lang-toggle-btn').forEach(function(b) { 
                    b.classList.remove('active'); 
                });
                e.target.classList.add('active');
                setMethodsLang('orig');
            } else if (e.target && e.target.id === 'lang-english-methods') {
                document.querySelectorAll('.lang-toggle-btn').forEach(function(b) { 
                    b.classList.remove('active'); 
                });
                e.target.classList.add('active');
                setMethodsLang('en');
            }
        });
        
        setMethodsLang('orig');
    });
    </script>
    '''
    
    return css + lang_toggle + table_html + script

html_block = render_extra_methods_table()
display(HTML(html_block))
```
